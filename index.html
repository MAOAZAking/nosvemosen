<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YA CASI NOS VEMOS</title>
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: url('A_digital_illustration_captures_a_sky_during_sunse.png') no-repeat center center fixed;
      background-size: cover;
      overflow: hidden;
    }
    h1 {
      text-align: center;
      font-size: 3em;
      color: #fff;
      margin-top: 30px;
      text-shadow: 2px 2px 5px rgba(0,0,0,0.7);
    }
    #countdown {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 1.3em;
      color: #fff;
      background-color: rgba(0,0,0,0.4);
      padding: 10px 15px;
      border-radius: 10px;
    }
    #pulseCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      /* El canvas estar치 detr치s del coraz칩n pero sobre el fondo */
      z-index: 1;
    }
    .heart-container {
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 2;
      /* Aumentamos el tama침o para que todos los corazones sean m치s grandes */
      width: 200px;
      height: 200px;
    }
    .heart-stage {
      position: absolute;
      width: 100%;
      height: 100%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      opacity: 0;
      transition: opacity 1s ease;
    }
    .visible {
      opacity: 1;
    }
    .heartbeat {
      animation: beat 1s infinite;
    }
    @keyframes beat {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    #final-message {
      position: absolute;
      /* Centrado horizontalmente y posicionado sobre el coraz칩n final */
      width: 90%;
      max-width: 500px; /* Evita que sea demasiado ancho en pantallas grandes */
      top: calc(50% - 180px); /* Colocado 30px sobre el borde superior del coraz칩n final */
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      color: white;
      font-size: 1.5em;
      font-weight: bold;
      opacity: 0;
      transition: opacity 2s ease;
      text-shadow: 2px 2px 5px black;
    }
    #final-message.visible {
      opacity: 1;
    }

    .container {
      position: relative;
      width: 200px;
      height: 200px;
    }

    .pixel-grid {
      position: absolute;
      top: 55%; /* <-- NUEVO: antes era 50% */
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
    }


    .pixel {
        position: absolute;
        width: 5px;
        height: 5px;
        background-color: #ff3366;
        box-shadow: 0 0 2px #ff0066;
        opacity: 0;
        transition: transform 1s ease-in-out, opacity 1s ease-in-out, background-color 0.3s ease, box-shadow 0.3s ease;
    }

    .pixel.start-left {
        transform: translateX(-100px);
    }

    .pixel.start-right {
        transform: translateX(100px);
    }

    .pixel.visible {
        opacity: 1;
        transform: translateX(0);
    }

    .pixel.venda {
        background-color: #ffffff;
        box-shadow: 0 0 3px #ffffff;
    }

    /* Efectos visuales */
    .emoji-heart {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 11.5rem; /* Escalado para 200px */
        opacity: 0;
        pointer-events: none;
        z-index: 10;
        animation: emoji-fade 1s forwards 10s;
    }

    @keyframes emoji-fade {
        from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    }

    .glow {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, rgba(255,51,102,0.8) 0%, rgba(255,51,102,0) 70%);
        opacity: 0;
        pointer-events: none;
        animation: glow-pulse 2s infinite 6s;
    }

    @keyframes glow-pulse {
        0%, 100% {
            opacity: 0.3;
            transform: translate(-50%, -50%) scale(1);
        }
        50% {
            opacity: 0.6;
            transform: translate(-50%, -50%) scale(1.1);
        }
    }
  </style>
</head>
<body>
  <h1>YA CASI NOS VEMOS</h1>
  <canvas id="pulseCanvas"></canvas>
  <div class="container">
    <div class="pixel-grid" id="heart-grid"></div>
    <div class="emoji-heart">游눘</div>
    <div class="glow"></div>
  </div>

  <div class="heart-container" id="heartContainer">
    <div class="heart-stage" id="stage1" style="background-image: url('heart_broken.png');"></div>
    <div class="heart-stage" id="stage2" style="background-image: url('heart_bandaged.png');"></div>
    <div class="heart-stage" id="stage3" style="background-image: url('heart_healing.png');"></div>
    <!-- El coraz칩n final usa el tama침o del contenedor y se desplaza 50px hacia arriba -->
    <div class="heart-stage" id="stage4" style="background-image: url('new_heart_full.png'); transform: translateY(-50px);"></div>
  </div>
  <div id="countdown">Cargando...</div>
  <div id="final-message">Esperame amor, ya casi llega el momento <br> de poder estar en tus brazos <br> 游봋 </div>
  <script>
    const canvas = document.getElementById('pulseCanvas');
    const ctx = canvas.getContext('2d');

    // Inicializaci칩n b치sica del pulso
    let pulsePoints = [];
    let pathIndex = 0;
    let pulseSpeed = 1;
    let pulseAmplitude = 0.5;

    const countdownEl = document.getElementById("countdown");
    const finalMessage = document.getElementById("final-message");
    const heartStages = [
      document.getElementById("stage1"),
      document.getElementById("stage2"),
      document.getElementById("stage3"),
      document.getElementById("stage4")
    ];
    const heartContainer = document.getElementById("heartContainer");
    const maxPoints = window.innerWidth;

    let x = 0;
    let lastY;

    // Puntos que definen la forma de un latido (200 puntos en total)
    const ekgPath = [].concat(
        Array(70).fill(0), 
        [2, 4, 5, 4, 2],   
        Array(10).fill(0), 
        [-5],              
        [10, 20, 30, 40, 50, 40, 30, 20, 10], 
        [-15, -20, -15],   
        Array(15).fill(0), 
        [5, 10, 12, 13, 12, 10, 5], 
        Array(80).fill(0)  
    );

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        lastY = canvas.height / 2; 
    }

    function drawPulse() {
      requestAnimationFrame(drawPulse);

      // Limpia la columna que se va a dibujar
      ctx.clearRect(x, 0, 8, canvas.height);

      const now = new Date();

      const midY = canvas.height / 2;

      if (now < pulseStartDate) {
        // Modo l칤nea recta: dibuja l칤nea horizontal constante

        const currentY = midY;

        // Dibuja l칤nea conectando desde lastY a currentY
        // === L칤nea blanca principal ===
        ctx.beginPath();
        ctx.moveTo(x - 1, lastY);
        ctx.lineTo(x, currentY);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // === L칤nea roja (2px m치s abajo) ===
        ctx.beginPath();
        ctx.moveTo(x - 3, lastY + 2);
        ctx.lineTo(x - 2, currentY + 2);
        ctx.strokeStyle = 'rgba(255, 120, 28, 0.9)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // === L칤nea fucsia/lila (4px m치s abajo) ===
        ctx.beginPath();
        ctx.moveTo(x - 5, lastY + 4);
        ctx.lineTo(x - 4, currentY + 4);
        ctx.strokeStyle = 'rgba(240, 84, 247, 0.9)';
        ctx.lineWidth = 2;
        ctx.stroke();


        // Actualiza variables para la siguiente iteraci칩n
        lastY = currentY;
        x++;
        if (x > canvas.width) x = 0;

        // pathIndex no avanza para no alterar el pulso a칰n
        return;  // Aqu칤 podr칤as quitar el return para evitar errores, o dejarlo
      } else {
          // Modo pulso: empieza la animaci칩n normal
          const elapsed = now - pulseStartDate;
          const phaseDuration = (targetDate - pulseStartDate) / 5;

          let maxPeak = 10;  // default
          if (elapsed < phaseDuration) {
            maxPeak = 25;
            pulseSpeed = 1;
          } else if (elapsed < 2 * phaseDuration) {
            maxPeak = 50;
            pulseSpeed = 1;
          } else if (elapsed < 3 * phaseDuration) {
            maxPeak = 75;
            pulseSpeed = 1;
          } else if (elapsed < 4 * phaseDuration) {
            maxPeak = 125;
            pulseSpeed = 1;
          } else {
            maxPeak = 125;
            pulseSpeed = 10 + Math.min(15, ((now - (pulseStartDate.getTime() + 4 * phaseDuration)) / (targetDate - (pulseStartDate.getTime() + 4 * phaseDuration))) * 15);
          }

          // Escalar el valor de ekgPath al rango m치ximo deseado
          const baseValue = ekgPath[pathIndex] || 0;
          let scaledOffset = 0;

          if (baseValue !== 0) {
            const maxRawValue = 50; // el valor m치s alto que aparece en ekgPath
            const scaleFactor = maxPeak / maxRawValue;

            // Aplica algo de aleatoriedad dentro del rango permitido
            scaledOffset = baseValue * scaleFactor * (0.8 + Math.random() * 0.4);
          }

          const midY = canvas.height / 2;
          const currentY = midY - scaledOffset;

          // Dibuja l칤nea principal (blanca)
          ctx.beginPath();
          ctx.moveTo(x - 1, lastY);
          ctx.lineTo(x, currentY);
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.lineWidth = 2;
          ctx.stroke();

          // L칤nea roja
          ctx.beginPath();
          ctx.moveTo(x - 3, lastY + 2);
          ctx.lineTo(x - 2, currentY + 2);
          ctx.strokeStyle = 'rgba(255, 120, 28, 0.9)';
          ctx.lineWidth = 2;
          ctx.stroke();

          // L칤nea fucsia
          ctx.beginPath();
          ctx.moveTo(x - 5, lastY + 4);
          ctx.lineTo(x - 4, currentY + 4);
          ctx.strokeStyle = 'rgba(240, 84, 247, 0.9)';
          ctx.lineWidth = 2;
          ctx.stroke();

          lastY = currentY;
          x++;
          pathIndex = (pathIndex + 1) % ekgPath.length;
          if (x > canvas.width) x = 0;
        }
    }



    // Usamos n칰meros para crear la fecha y evitar problemas de formato.
    // OJO: El mes es 0-indexado (0=Enero, 7=Agosto).
    const targetDate = new Date(2025, 7, 21, 14, 37, 0);

    // 춰Importante! La fecha de inicio para la animaci칩n debe ser en el pasado.
    // C치mbiala por la fecha en que comenz칩 su cuenta regresiva.
    // OJO: El mes es 0-indexado (0=Enero, 4=Mayo).
    const startDate = new Date(2024, 4, 1, 0, 0, 0);
    const pulseStartDate = new Date(2025, 7, 20, 15, 54, 0);

    const totalPulseDuration = targetDate - pulseStartDate;
    const segmentDuration = totalPulseDuration / 5;

    const phase1End = new Date(pulseStartDate.getTime() + segmentDuration * 1);
    const phase2End = new Date(pulseStartDate.getTime() + segmentDuration * 2);
    const phase3End = new Date(pulseStartDate.getTime() + segmentDuration * 3);
    const phase4End = new Date(pulseStartDate.getTime() + segmentDuration * 4);


    let countdownInterval; // Para poder detener el temporizador al final

    function updateCountdown() {
      const now = new Date();
      const diff = targetDate - now;

      const elapsedDuration = now - startDate;
      const totalDuration = targetDate - startDate;
      const progressToFinal = Math.max(0, elapsedDuration / totalDuration);

      const pulsePhaseDuration = targetDate - pulseStartDate;
      const pulseElapsed = now - pulseStartDate;
      const pulseProgress = Math.max(0, Math.min(1, pulseElapsed / pulsePhaseDuration));

      if (diff <= 0) {
        countdownEl.textContent = "00d 00h 00m 00s";
        heartStages.forEach(stage => stage.classList.remove("visible"));
        heartStages[3].classList.add("visible");
        heartContainer.classList.add("heartbeat");
        finalMessage.classList.add("visible");
        // Antes de las 2:45 PM, sin pulso (l칤nea recta)
        if (now < pulseStartDate) {
          pulseSpeed = 1;
          pulseAmplitude = 0;
        } else {
          // A partir de las 2:45 PM, aumenta velocidad y amplitud seg칰n pulseProgress
          const minSpeed = 1;
          const maxSpeed = 25;
          pulseSpeed = minSpeed + (maxSpeed - minSpeed) * pulseProgress;

          // La amplitud se usar치 din치micamente en drawPulse()
        }

        if (countdownInterval) clearInterval(countdownInterval); // Detiene las actualizaciones
        return;
      }

      const days = Math.floor(diff / (1000 * 60 * 60 * 24));
      const hours = Math.floor((diff / (1000 * 60 * 60)) % 24);
      const minutes = Math.floor((diff / (1000 * 60)) % 60);
      const seconds = Math.floor((diff / 1000) % 60);
      countdownEl.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;

      // --- L칩gica corregida para la animaci칩n del coraz칩n ---
      const totalStages = heartStages.length;
      const progress = Math.max(0, elapsedDuration / totalDuration);
      const stageIndex = Math.min(totalStages - 1, Math.floor(progress * totalStages));

      heartStages.forEach((h, i) => h.classList.remove("visible"));
      heartStages[stageIndex].classList.add("visible");

      // --- L칩gica para acelerar y aumentar el pulso del Canvas ---
      const progressNormalized = Math.max(0, Math.min(1, progress)); // Asegurar que est칠 entre 0 y 1
      
      // Velocidad: de 1 (lento) a 10 (r치pido)
      const minSpeed = 1;
      const maxSpeed = 25;
      pulseSpeed = minSpeed + (maxSpeed - minSpeed) * progressNormalized;

      // Amplitud: de 0.5 (bajo) a 1.5 (alto)
      const minAmplitude = 0.5;
      const maxAmplitude = 2.5;
      pulseAmplitude = minAmplitude + (maxAmplitude - minAmplitude) * progressNormalized;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Ajusta el canvas al tama침o inicial
    drawPulse(); // Inicia la animaci칩n del canvas
    countdownInterval = setInterval(updateCountdown, 1000);
    updateCountdown();
    // Este es el fragmento clave

    const heartMatrix = [
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0],
            [0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        ];

    const heartMatrixRows = heartMatrix.length;
    const heartMatrixCols = heartMatrix[0].length;
    const pixelSize = 5;
    const animationDelayPerPixel = 7;
    const grid = document.getElementById('heart-grid');
    const leftHalfPixels = heartMatrix.reduce((sum, row) => sum + row.slice(0, Math.floor(heartMatrixCols / 2)).filter(p => p === 1).length, 0);
    const rightHalfPixels = heartMatrix.reduce((sum, row) => sum + row.slice(Math.floor(heartMatrixCols / 2)).filter(p => p === 1).length, 0);
    const pauseBetweenHalves = 500;
    const totalAnimationDuration = (leftHalfPixels * animationDelayPerPixel) + pauseBetweenHalves + (rightHalfPixels * animationDelayPerPixel);

    function createHeart() {
        let leftSideDelay = 0;
        const rightSideStartDelay = (leftHalfPixels * animationDelayPerPixel) + pauseBetweenHalves;

        function drawLeftHalf() {
            for (let y = 0; y < heartMatrixRows; y++) {
                for (let x = 0; x < Math.floor(heartMatrixCols / 2); x++) {
                    if (heartMatrix[y][x] === 1) {
                        setTimeout(() => {
                            const pixel = document.createElement('div');
                            pixel.className = 'pixel start-left';
                            pixel.dataset.row = y;
                            pixel.dataset.col = x;
                            pixel.style.top = `${y * pixelSize}px`;
                            pixel.style.left = `${x * pixelSize}px`;
                            grid.appendChild(pixel);
                            setTimeout(() => {
                                pixel.classList.add('visible');
                            }, 50);
                        }, leftSideDelay);
                        leftSideDelay += animationDelayPerPixel;
                    }
                }
            }
        }

        function drawRightHalf() {
            let rightSideDelay = 0;
            for (let y = 0; y < heartMatrixRows; y++) {
                for (let x = Math.floor(heartMatrixCols / 2); x < heartMatrixCols; x++) {
                    if (heartMatrix[y][x] === 1) {
                        setTimeout(() => {
                            const pixel = document.createElement('div');
                            pixel.className = 'pixel start-right';
                            pixel.dataset.row = y;
                            pixel.dataset.col = x;
                            pixel.style.top = `${y * pixelSize}px`;
                            pixel.style.left = `${x * pixelSize}px`;
                            grid.appendChild(pixel);
                            setTimeout(() => {
                                pixel.classList.add('visible');
                            }, 50);
                        }, rightSideDelay);
                        rightSideDelay += animationDelayPerPixel;
                    }
                }
            }
        }

        drawLeftHalf();
        setTimeout(drawRightHalf, rightSideStartDelay);
        setTimeout(applyEffects, totalAnimationDuration);
    }

    function applyEffects() {
        const effectsStartDelay = 2000;
        setTimeout(() => {
            const allPixels = Array.from(document.querySelectorAll('.pixel'));
            const vendaRows = [14, 15, 16, 17, 18, 19, 20];
            let vendaDelay = 0;
            vendaRows.forEach(row => {
                const rowPixels = allPixels.filter(p => parseInt(p.dataset.row) === row);
                rowPixels.sort((a, b) => parseInt(a.dataset.col) - parseInt(b.dataset.col));
                rowPixels.forEach(pixel => {
                    setTimeout(() => {
                        pixel.classList.add('venda');
                    }, vendaDelay);
                    vendaDelay += 10;
                });
            });
        }, effectsStartDelay);

        setTimeout(() => {
            const allPixels = Array.from(document.querySelectorAll('.pixel'));
            const diagonalPixels = allPixels.filter(pixel => {
                const row = parseInt(pixel.dataset.row);
                const col = parseInt(pixel.dataset.col);
                return (
                    (row >= 10 && row <= 22) &&
                    (col >= 20 && col <= 39) &&
                    (col - row > 10)
                );
            });
            diagonalPixels.sort((a, b) => parseInt(a.dataset.row) - parseInt(b.dataset.col));
            let diagonalDelay = 0;
            diagonalPixels.forEach(pixel => {
                setTimeout(() => {
                    pixel.classList.add('venda');
                }, diagonalDelay);
                diagonalDelay += 10;
            });
        }, effectsStartDelay + 1000);

        setTimeout(() => {
            const allPixels = document.querySelectorAll('.pixel');
            allPixels.forEach(pixel => {
                pixel.style.transition = 'all 0.5s ease';
                pixel.style.transform = `translate(${Math.random() * 200 - 100}px, ${Math.random() * 200 - 100}px) scale(0.2)`;
                pixel.style.opacity = '0';
            });
        }, effectsStartDelay + 3500);
    }

    createHeart();
  </script>
</body>
</html>